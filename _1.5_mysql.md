## Mysql

### 1 基础

#### 1.1 基本相关

> 结构

mysql有三层结构，数据库管理系统、数据库、表

在电脑上安装数据库，实际上就是在主机上安装了一个数据库管理系统（DBMS），这个管理程序可以管理多个数据库。

```
<select id="getPersonById" parameterType="Integer" resultType="Person">
    SELECT * FROM `person` WHERE `id` = #{id}
</select>
```

一个数据库中可以创建多个表，以保存数据

数据库管理系统、数据库、表的关系如下：



![e463f7701785d1e1f2c16ed5c4d269f9](/Users/changhe/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/nt_qq_20a8d2bc7cad483944f4c07642609169/nt_data/Pic/2023-05/Ori/e463f7701785d1e1f2c16ed5c4d269f9.png)

（数据库内不止有表，但是表是最重要的内容）

客户端通过端口连接进数据库，如通过默认端口3306连接近本机的数据库。



Mysql数据库管理系统的本质是一个叫做mysqld.exe(window系统上)的应用程序。

Mysql数据库的本质是叫做db01、db02、db03...的文件夹

Mysql表的本质是db01等文件夹里面的具体文件



表的结构一般由行（row）和列（column）组成。表的一行称之为一条记录，往往由一个对象表示一行记录。



> 启动指令

以下命令在用管理员身份运行的终端中输入

```
mysql -h 主机ip地址 -P 端口号 -u 用户名 -p密码
```

该命令为进入数据库的命令，若-h不写，则默认为本机；若-P不写，则默认端口号为3306；若密码不写，则会在回车后输入密码（注意密码与-p直接没有空格）



```
net start mysql;
net stop mysql; //window系统开关sql的指令
sudo mysql.server start
sudo mysql.server stop //mac系统开关sql的指令
```

上述指令为在终端开启关闭数据库的指令



数据库相关指令有：

​	数据定义语句，如create等；

​	数据操作语句，如insert、update、delete等；

​	数据查询语句，如select等

​	数据控制语句



#### 1.2 数据类型

所谓数据类型（也称字段类型），实际上是指的表内的列类型。表的一行代表一组数据，表的每列则表示此处数据的类型。简单举个例子如下

|       | id   | name    | password | Birthday |
| ----- | ---- | ------- | -------- | -------- |
| user1 | 01   | changhe | 123      | 2.11     |
| User2 | 02   | hechang | 321      | 3.11     |

此处每行代表了一个用户，而每列则是用户的具体信息。但是如何确定每列用来存储什么数据类型呢？比如id应该存int类型比较合适，name则不应该存int类型。

此时就需要指定表的字段类型（列的数据类型），来规范一下这个表。

要将mysql的数据类型和java中的数据类型区分开，这俩没那么像。

mysql的数据类型可以分四大类：数值类型、文本类型、二进制类型、时间类型。



> 数值类型

数值类型就可以理解为是java中的数字类型，都是都阿拉伯数字组成的。

数值类型中可以分为两小型：整型、小数类型。

其中整型的分类如下：

|                      | tinyint     | smallint          | medumint         | Int              | bigint           |
| -------------------- | ----------- | ----------------- | ---------------- | ---------------- | ---------------- |
| 所占字节数           | 1字节       | 2字节             | 3字节            | 4字节            | 8字节            |
| 带符号位的范围(默认) | [-128, 127] | [-2^15, 2^15 - 1] | [-2^23,2^23 - 1] | [2^31, 2^31 - 1] | [2^63, 2^63 - 1] |
| 无符号位的范围       | [0,255]     | [0,2^16 - 1]      | [0, 2^24 - 1]    | [0, 2^32 - 1]    | [0, 2^64 - 1]    |



小数类型分类如下：

|            | Float(单精度) | double（双精度） | Decimal[M,D](MD具体代表啥后面会说) |
| ---------- | ------------- | ---------------- | ---------------------------------- |
| 所占字节数 | 4字节         | 8字节            | 看M和D的大小                       |
|            |               |                  |                                    |
|            |               |                  |                                    |



decimal型是要指定一个D和M的。其中M是总位数，D是小数点后的位数。

如decimal[5,2]，则代表一共有五位数，小数点后面有2位，形如385.45。

若没指定M和D，则M默认为10，D默认位０。

```mysql
CREATE TALBE `T`(
`MONEY` DECIMA(30,20)
)
INSERT INTO `T` VALUES(65465.64351321385436854)
# 可以成功，小数不够的话在后面补零，补到20个小数即可。
```







> 文本类型

文本类型可以理解为java中的String类型，是由字符组成的

其分类如下

|              | char    | varchar      | text        | longtext     |
| ------------ | ------- | ------------ | ----------- | ------------ |
| 可表示的范围 | [0,255] | [0,2^16 - 1] | [0,2^16 -1] | [0,2^32 - 1] |



char是固定长度字符串，最大字符为255字符。所占字节数看编码类型，若是utf8则是最多255*3个字节。

char有一个细节，如定义时定义CHAR(4)，则哪怕只往里输入两个字符，它也是占用了四个字符的长度



varchar是可变长度的字符串，其明面上的字节范围为0~65535。但若用uft8编码的话最大字符数为21844个字符。因为65535个字节要有1~3个字节用于记录大小，而utf8的编码会将3个字节编一个字符，故varchar的字符编码最大长度为65532/3=21844个字符。21844只是utf8编码时的最大长度，若是其他的则最大长度会有所不同，如gbk编码就应该是65532/2。

与char里定长的空间不同，varchar是变长的空间，即哪怕定义VARCHAR(21844)，然后只往里塞两个字符，其也只占用两个字符的空间+1~3个字节的记录长度，而不是占用21844个字符空间。即varchar空间长度为：实际输入字符长度+1~3个字节



虽然从上述看，varchar的优势要大于char，但实际不然。char的查询速度是要比varchar快的。因此在记录一些定长的数据时（如手机号、身份证号），一般用char；对于一些不一定有多长的数据时（如聊天输入框等等），一般用varchar。

```mysql
create table `T01`(
	'name' CHAR(256)
) #报错，因为256超出255的范围了


CREATE TABLE `T02`(
    'NAME' CHAR(4)
)#成功，此时表示NAME里可存放四个字符，无论中文还是英文还是数字，都算一个
INSERT INTO T02 VALUES('ABCD123') #失败，因为添加的字符数有7个，而只能承载4个
# 有一个细节，如果输入为'20'(里面是任意数字)这种纯数字组成的字符串，则mysql内部会将其尝试转为int，当然char是一定可以接受被引起来的纯数字的，但是int也有可能能接受这种类型的数据

CREATE TABLE `T03`(
	'NAME' VARCHAR(21845)
) #报错，因为21855在utf8编码编码时已经超出21844的最大字符范围了

```



如果varchar都不够用了，可以考虑使用mediumtext或longtext来记录数据。





> 二进制数据类型

二进制数据类型为新类型，后面会细说

其分类如下

|            | blob       | longblob   |
| ---------- | ---------- | ---------- |
| 可表示范围 | [0,2^16-1] | [0,2^32-1] |
|            |            |            |



> 时间类型

时间类型分两类：日期类型和时间类型

日期类型是表示年月日的，不能精确到时分秒

时间类型则是单独表示时分秒的

然后还有一个集大成者，既可表示年月日，又可表示时分秒

| date         | time         | datetime            |
| ------------ | ------------ | ------------------- |
| 只表示年月日 | 只表示时分秒 | 表示年月日和时分秒  |
|              |              | YYYY-MM-DD HH:mm:ss |
|              |              |                     |

此外还有一个类型叫时间戳--timestamp，可以时时获取当前时间。

```mysql
CREATE TABLE `T01`(
	'BIRTHDAY' DATE , --生日
	'JOB_TIME' DATETIME, --记录年月日
	'LOGIN_TIME' TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP 
    						ON UPDATE CURRENT_TIMESTAMP --获取当前时间，后面那一串是配置代码，得带着
)	
INSERT INTO T01('BIRTHDAY','JOB_TIME') VALUES ('2000-08-28','2000-08-28 10:10:10') #分别向birthday和jobtime中加入时间，data只记录年月日，datetime记录年月日 时分秒。而timestamp不主动添加时，会默认以当前时间自动更新。
```



#### 1.3 存储引擎

mysql的表类型是由存储引擎（storage engines）决定的，存储引擎主要有以下三个：MyISAM、innoDB、Memory。

这三种引擎分为两类：事务安全型：innoDB 和非事务安全型：MyISAM和Memory。所谓事务安全不安全就是支持不支持事务存在。

不支持事务的引擎进行数据操作会更快。

下面对三种引擎的优劣进行一一比对说明

| 特点       | MyISAM | innoDB | Memory |
| ---------- | ------ | ------ | ------ |
| 插入速度   | 高     | 低     | 高     |
| 事务安全   | 不支持 | 支持   | 不支持 |
| 全文索引   | 支持   | 不支持 | 不支持 |
| 锁机制     | 表锁   | 行锁   | 表锁   |
| 存储限制   | 没有   | 64TB   | 有     |
| B树索引    | 支持   | 支持   | 支持   |
| 哈希索引   | 不支持 | 支持   | 支持   |
| 集群索引   | 不支持 | 支持   | 不支持 |
| 数据缓存   | 不支持 | 支持   | 支持   |
| 索引缓存   | 支持   | 支持   | 支持   |
| 数据可压缩 | 支持   | 不支持 | 不支持 |
| 空间使用   | 低     | 高     | 看情况 |
| 内存使用   | 低     | 高     | 中等   |
| 外键       | 不支持 | 支持   | 不支持 |

小结一下：

myisam：不支持事务、不支持外键，但是访问速度块

innodb：支持事务，占更多的磁盘空间以保存事务和索引

memory：该引擎使用存在内存中的内容来创建表。也就是说memory是基于内存的表，其速度极快，但是一旦关机，通过memory建立的表的内容就消失了，但是其表的结构还在（就是表的各个列信息还在，但是存入表内的内容就没了）





### 2 语法

#### 2.1 数据库语句

> 定义

数据库定义语句如下：

```mysql
CREATE DATABASE[IF NOT EXISTS]db_name；  # 其中if not exists是防止冲突用的，如过当前数据库列表中已经存在db_name了，则不会进行创建，若不加这个指令，则会报错
CREATE DATABASE db_name CHARACTER SET utf8 COLLATE utf8_bin
# character set是指定字符集的指令，不指定则默认utf8；collate是指定校对规则的，不知道则默认utf8_bin（不区分大小写的规则）
```



> 查询

查看当前所有的数据库有哪些用下面的指令

```mysql
SHOW DATABASES  #查看当前数据库服务器中有哪些数据库。注意，此处databases是加s的
SHOW CREATE DATABASE xxx #查看名称为xxx的数据库的定义信息，如字符集是什么、校对规则是什么
```



> 删除

删除某个数据库用下面的语句

```mysql
DROP DATABASE xxx  #删除xxx数据库
```



> 备份

备份某个数据库的语句为

```mysql
mysqldump -u 用户名（一般为root） -p密码 -B 数据库1、数据库2（欲备份的数据库名称） > 欲保存的地址/欲命名的文件名.sql
```

备份就是将数据库服务器中的某个数据库备份为一个文件保存到本地



若想备份某个数据库中某个表，则用下述语句

```mysql
mysqldump -u 用户名 -p密码 数据库（欲备份的数据库） 表（欲备份的数据库下面的欲备份的表） > 欲保存的地址/欲命名的文件名.sql
```



> 恢复

恢复数据库的语句为

```mysql
source 备份过后的数据库的本地文件的地址（即上面定义的：欲保存的地址/欲命名的文件名.sql）
```

恢复数据是将从数据库服务器中删除掉的数据库恢复到服务器中



要注意，恢复和备份必须在终端执行语句，不能在其他的编译器中执行。



#### 2.2 表的语句

上面介绍了数据库的基本语句，现在详细介绍一下数据库下的核心组件--表的语句

> 创建

创建表用以下语句

```mysql
CREATE TABLE xxx(
	field1 datatype
  field2 datatype
)
character set 字符集
collate 校对规则
engine 引擎

# 其中xxx是指新表的名称、field是指定表中的列名、datatype是指定列的字段类型、字符集之前介绍过，若不指定，则默认为所在数据库的规则、校对规则回头自己简单查一下、engine后面再介绍。
```



> 修改

修改表分为修改表本体和修改表列。修改表本体常用修改表名、修改表字符集；修改列一般为添加列、修改列、删除列和显示当前全部列。

以下面要求举例：假设当前有一个员工emp表，表内有name列、resume列、job列、sex列。在表上增加一个image、varchar类型的列并让其在resume后面，修改job列让其长度为60、删除sex列、表面改为employee、修改字符集为utf8、修改列明name为username

```mysql
ALTER TABLE emp ADD 'image' VARCHAR(32) --在emp表中加入一个名为image的列，其数据类型为varchar（32）
									  NOT NULL --该表不允许为空
									  DEFAULT '' --该表初始化为一个空字符
									  AFTER resume --指定该列在resume后面

ALTER TABLE emp MODIFY 'JOB' VARCHAR(60) --将JOB的长度更改为60
										NOT NULL DEFAULT '' 

ALTER TABLE emp DROP 'sex' --删除sex列

RENAME TABLE emp TO employee --将表名更改为employee

ALTER TABLE employee CHARACTER SET utf8 --将表的字符集改为utf8

ALTER TABLE employee CHANGE 'NAME' 'USER_NAME' VARCHAR(32) NOT NULL DEFAULT ''  --将列name改为user_name

DESC employee --显示当前表的各个列
```



### 3 增删改查

本节将介绍数据库中表的四大操作--增删改查（create、delete、update、read），但是一般说CRUD。

#### 3.1 增

增用insert语句，之前已经见过很多次了，现在详细讲讲。



> 语法

其基本语法如下

```mysql
INSERT INTO `table_name`(Column1,column2,,,) VALUES (value1,value2,,,);
```

表名后面跟的是要添加的列名分别为什么，values后面跟的是各个列中欲加入的值。



> 细节

1、填入的数据应该与其对应列定义的数据类型相符合，如将100添加进INT、将'NAME'添加进CHAR。而将'NAME'添加进INT则不成功。注意类型的时候也要注意各个类型定义的长度也要大于等于欲添加的数据长度。



2、在VALUES后面的数据与列是一一对应的，即column1对应value1、column2对应value2.



3、字符和日期类型的数据应该用单引号引起来。即'CHAR'，’yyyy-mm-dd‘。



4、列可以插入空值（前提是该列可以插入空值）

```mysql
CREATE TABLE `T`('NAME' VARCHAR(10) NOT NULL) #创建表时指定NAME列不可有null

INSERT TABLE `T`（`NAME`） VALUES (NULL) # 添加失败，因为指定NAME列下不可有null了
```



5、也可以做到一条语句完成对某一列的多次添加

```mysql
INSERT TABLE `T`('NAME','ID') VALUES ('HE', 1),('LI', 2),('LIU', 3); # 一口气添加三条数据进表
```



6、若想给所有列添加数据，则可不写table_name后的列名列表。



7、添加的数据的个数一定要与列的个数想匹配。若添加的数据多于列数，则一定报错。



8、若不给某个列添加数据时，如有默认值（一般默认值为null）则添加默认值，若没有则报错。

```mysql
CREATE TABLE `T`('NAME' VARCHAR(10) ,
                'ID' INT
                'PRICE' DOUBLE)
INSERT INTO `T`('NAME', 'PRICE') VALUES ('HE',100)
#此处没有给id添加数据，而id列又没有限制数据不能为空，故会为id默认分配null

#也可以指定默认值为多少，只需在定义列类型的后面加上 DEFAULT XXX
```



#### 3.2 改

改用update语句



> 语法

```mysql
UPDATE `table_name` SET column_name1 = xxx WHERE column_name2 = xxx
```

该语句的意思是，将表table_name中的column_name2列中xxx行的column_name1列改为xxx。如

将`员工`表中`name`列里`小明`所在行的`薪水`列改为`100`



> 细节

1、若不使用where后缀，则会将column_name1中所有的数据都改了。



2、若要修改多个字段，则使用如下语法

```mysql
UPDATE `T` SET column_name1 = xxx , column_name2 = xxx WHERE column_name3 = xxx
```

一下改column_name1列和column_name2列的内容（column_name3 = xxx行所对应）



#### 3.3 删

删除用delete语句



> 语法

```mysql
DELETE FROM `T` WHERE column_name1 = xxx 
```

将表`T`中`column_name1`列里等于xxx的行删除



> 细节

1、若不指定where，则会删除表中所有内容。



2、删除是按行删的，不能删除某一列。



3、delete最多删除表的记录内容，不能删除表本身。若想删除表本身，用DROP语句

```mysql
DROP TALBE `T` #将表T删除
```



#### 3.4 查

查可以算是表的操作里最重要也内容最多的部分。

查用select语句



> 语法

```mysql
SELECT DISTINCT */column_name1,column_name2,,, FROM `T`
```

此语法为最简略的语法，解释一下该语法，DISTINCT是将查询结果中重复的行删除（该关键字可不加），*是查询全部列、若不想查全部列则指定想查列的列名即可。FROM T则是在T表中查询数据。



> 案例

对select多讲一个案例

案例用一个例子讲解。假设现在有下表`T`

| id   | name | math | english | Chinese |
| ---- | ---- | ---- | ------- | ------- |
| 1    | 小明 | 98   | 51      | 64      |
| 2    | 小红 | 65   | 88      | 97      |
| 3    | 小强 | 65   | 91      | 54      |



1、查询表中所有学生信息

```mysql
SELECT * FROM `T`
```



2、查询表中所有学生信息并去除重复

```mysql
SELECT DISTINCT * FROM `T`
```

去重是只有某一行和前面的行数据每一列都相同才去重，否则不算重复。

当然，若查的列数越精确，则重复的概率越大。如查全部表则没有一行是重复的，但如下查找则会去重

```mysql
SELECT DISTINCT math FROM `T` #此时由于小红和小强的数学成绩都是65，故会当重复的去除其中一行
```



3、还可以指定某几列进行某种运算

```mysql
SELECT `name`, (math + english + chinese) FROM `T`
```

select语句是`SELECT`后面与`FROM`前面之间有几个输入，结果就输出几列。这里括号内算一个输入，故一共只有两个输入，一个是name，一个是三个列的和。

此时输出为

| name | math + english + chinese |
| ---- | ------------------------ |
| 小明 | 213                      |
| 小红 | 250                      |
| 小强 | 210                      |

若觉得第二列的列名不好看，可以使用as关键字改一下列名

```mysql
SELECT `name`　AS　`名字`,(math + english + chinese) AS `sum` FROM `T`
```

这里用AS将(math + english + chinese) 列名改为了列名sum，将name改为了名字



> 细节

1、SELECT语句是可以插入函数从而对某列的数据进行运算的

```mysql
SELECT expression(*) / expression(column_name1) ,expression(column_name2) FROM table_name
```

其中expression是想在对应列进行的运算函数，之后细说函数



2、WHERE关键字的使用。

查询语句也可以使用WHERE关键字来精确查找目标。但是查询语句中的where使用方法就复杂的多

先简单举例

```mysql
SELECT * FROM `T` WHERE `name` = `小明` # 查找T表里所有列中name=小明的那一行
```



在WHRER后面，可以跟的内容不止是这一种，其可跟：比较运算符（如<,>,=,!=等等）、区间（BETWEEN...AND...，即在哪哪哪到哪哪哪之间）、定位（IN(XXX,YY)，即查找xxx或yy的所在行）、模糊查询（LIKE XXX，如LIKE `张`表示显示某列中所有包含张的行）、逻辑运算符（and or not）。

下面简单展示一下

```mysql
SELECT * FROM `T` WHERE `math` > 80; # 查找所有列中math大于80的行
SELECT * FROM `T` WHERE (math + english + chniese) > 200 AND `name` LIKE `小%` # 查找所有列中总分大于200并且name以`小`开头的行。这里`%`代表0~多，即只要是小开头，后面不管是啥都行
SELECT * FROM `T` WHERE `math` > 70 AND `math` < 90 #查找所有列中数学成绩在70到90之间的行
SELECT * FROM `T` WHERE `math` BETWEEN 70 AND 90 #和上面的效果一样，也是查区间70到90的行，但是BETWEEN是闭区间
SELECT * FROM `T` WHERE `math` = 82 or 	`math` = 91 #查找数学成绩为82或91的行
SELECT * FROM `T` WHERE `math` IN (82,91) #和上面效果相同
```

补充几点：

1、mysql中，日期类型是可以直接比较大小的，如想查出生日期再2000年之后的人，可以用 WHERE BIRTHDAY > '1999-12-31'

2、模糊查询时，若想查第二个、第三个..等其他位置的字符为某个子，则前面的字符用`_`顶掉。如WHERE `NAME` LIKE `_明%`，则时查第二个字是明的人



3、order by关键字的使用

order by关键字用来排序指定的列，该关键字位于select语句的结尾。

升序用Asc、降序用Desc。默认为升序

```mysql
SELECT * FROM `T` ORDER BY math # 将T表中按照math列的值进行升序排序
SELECT (math + english + chniese) AS `sum` FROM `T` ORDER BY `sum` DESC # 将表中的语数外成绩加起来命名为sum并降序排序
SELECT (math + english + chniese) AS `SUM` FROM `T` WHERE `NAME` LIKE `小%` ORDER BY `sum` #将表中姓小的人所在的行按照总成绩升序排序
```



### 4 函数

之前接受select语句的时候说过，select语句是可以添加函数的，这里详细说明一下可添加的函数。

mysql中提供的函数常用的有以下几种：合计函数、字符串函数、数学函数、日期函数、加密函数、流程控制函数。

当然，除了mysql提供的函数外，还可以自定义函数，就像java自定义方法一样。



#### 4.1 合计函数

合计函数也称统计函数，其有以下几种count、sum、AVG、max和min



##### 4.1.1 count

count函数是统计行数共有多少个的一种统计个数的函数

> 语法

其简单语法如下(还是用3.4节中示例用的小明、小红那张表举例)

```mysql
SELECT COUNT(*) FROM `T` # 统计表T中一共有多少行
SELECT COUNT(*) FROM `T` WHERE `math` > 80 # 统计表中数学大于80的行有几行
```



> 细节

count是统计行数的，所以看起来COUNT(**)与COUNT(column_name)没什么区别。但是其还是有一点小区别的，COUNT*(*)会统计表中所有行，包括null行；而count（某一列或某几列）虽然也是统计这几列中所有行，但不会将null行统计进去，即只返回非空值。



##### 4.1.2 sum

sum函数是统计满足WHRER条件的行数的对应列的和

> 语法

```mysql
SELECT SUM(`MATH`) FROM `T` # 统计T表中所有数学成绩的和。即班级中所有人的数学成绩的总和
SELECT SUM(`MATH`) AS `math_sum`, SUM(`ENGLISH`) AS english_sum FROM `T` WHERE `NAME` LIKE `小%` # 将所有姓小的人的数学成绩和英语成绩总和统计出来。
SELECT SUM(math+englis) / COUNT(*) FROM `T` # 计算班级中数学+英语成绩的平均分 
```



> 细节

sum函数只能用在数值列，若用在字符串列等其他不能用来计算加法的列上会报错



##### 4.1.3 avg

avg函数是计算平均数的函数，其基本用法与细节和sum函数大致相同，这里简单展示

```mysql
SELECT AVG(`MATH`) FORM `T` #计算全班数学成绩的平均分
```



##### 4.1.4 max、min

顾名思义，这俩是得出所查内容中最大值和最小值用的。也是只能用在数值列

```mysql
SELECT MAX(`MATH`) FROM `T`
SELECT MIN(MATH + ENGLISH + CHINESE) AS MIN_SUM FORM `T`
```



#### 4.2 分组函数

分组函数用的是GROUP BY语句，其意思就是，将表按GROUP BY后面的属性展开，比如GROUP BY ’性别‘，则原有的整个表会整合成两行，第一行是男（女），第二行是女（男），至于前面的各个列是什么，就看需要自己定义了



 有下三种表

部门表

| 部门编号 | 部门名称 | 部门位置 |
| -------- | -------- | -------- |
| 10       | 财务部   | 纽约     |
| 20       | 研发     | 北京     |
| 30       | 销售     | 芝加哥   |
| 40       | 业务     | 波士顿   |



员工表

| 员工编号 | 员工名字 | 岗位   | 上司编号 | 工资 | 所在部门 | 入职日期   |
| -------- | -------- | ------ | -------- | ---- | -------- | ---------- |
| 7788     | scoot    | 分析员 | 7566     | 3000 | 20       | 1997-04-19 |
| 7902     | ford     | 分析员 | 7566     | 3000 | 10       | 1991-12-03 |
| 7698     | blake    | 经理   | 7893     | 2850 | 30       | 1991-05-01 |
| 7566     | jones    | 经理   | 7893     | 2957 | 20       | 1991-04-02 |
| 7369     | smith    | 文员   | 7092     | 800  | 20       | 1990-12-17 |
| 7782     | clark    | 经理   | 7893     | 2450 | 10       | 1991-06-09 |
| 7893     | king     | 总经理 | NULL     | 5000 | 10       | 1991-11-17 |



工资级别表

| 工资级别 | 级别最低工资 | 级别最高工资 |
| -------- | ------------ | ------------ |
| 1        | 700          | 1200         |
| 2        | 1201         | 1400         |
| 3        | 1401         | 2000         |
| 4        | 2001         | 3000         |
| 5        | 3001         | 10000        |



实例应用

```mysql
# 若想查找每个部门的平均工资，则用传统方法是无法实现的，因为要查的列数有两列：员工表里的：奖金列和部分列。此时用分组查询的GROUP BY语句
SELECT AVG('工资'),'部门' FROM '员工表' GROUP BY '部门'  # 结果中显示平均工资和部门两列，这两列按部门个数分组，第一组（即第一行）为第一个部门的欲查信息、第二组为第二个部门的欲查信息

# 若查每个部门的每种岗位的平均工资，则需要在上面的基础上多查一次岗位的信息
SELECT AVG('工资') , '部门' ,'岗位' FROM '员工表' GROUP BY '部门' , '岗位' #该语句结果会将每个部门的每种岗位都以行为单位列出来，比如部门10有两个岗位、部门20有3个岗位，则该语句结果会有5行（是行不是列，哪几列由SELCT后面的信息确定），然后各个行的每一列分别为平均工资、部门、岗位

# 若想查平均工资低于2000的部门号和它的平均工资，则
SELECT AVG('工资'),'部门' FROM '员工表' GROUP BY '部门' HAVING AVG('工资') < 2000 #此处用了GROUP BY的常见后缀语句，HAVING，其效果是做一次筛选，将GROUP BY 后的表按满足HAVING后的条件再次进行筛选
```



#### 4.3 字符串函数

字符串函数种类挺多，下面列一个表整体介绍一下

| 函数名                                  | 功能                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| CHARSET(`str`)                          | 返回字串字符集                                               |
| CONCAT(`string`...)                     | 连接字串                                                     |
| INSTR(`string，substring`)              | 返回substring在string中出现的位置，没有则返回0               |
| UCASE(`string`)                         | 转小写为大写                                                 |
| LCASE(`string`)                         | 转大写为小写                                                 |
| LEFT(`string,length`)                   | 从string的左边起取第length个字符                             |
| LENGTH(`string`)                        | 获取string的长度                                             |
| REPLACE(`str, search_str ,replace_str`) | 将str中的search_str用research_str代替                        |
| STRCMP(`str1, str2`)                    | 逐字符比较两字符串的大小                                     |
| SUBSTRING(`str, position, [length]`)    | 从str的position字符开始，取length个字符。若不设length，则后面的全取 |



> 实用

下面简单实例应用一下上述各个功能

```mysql
SELECT CHARSET(`NAME`) FROM `T` #得到name列的编码类型
SELECT CONCAT(`NAME`, 'MATH SCORE IS' , `MATH`) AS `all` FROM `T` #此时会得到一个列，该列的名字为“all”,该列下每行的内容为：xxx MATH SCORE IS xxx
SELECT INSTR('强强','小强强') FROM DUAL # 得到结果为2，即强强是小强强从左向右数第二个开始的。最后的DUAL是亚元表，用作测试，当不需要用表的时候可以带上该表防止语法报错
SELECT UCASE(`NAME`) FROM `T` #将name列下所有内容转为大写，其他列不影响。LACSE同理
SELECT LEFT(`NAME`,2) FROM `T` #对于name列下的所有内容，只取前两个值，后面的不记。LEFT还可以换成RIGHT，从右开始取。
SELECT LENGTH(`NAME`) FROM `T` #结果为name列下各个内容的字节大小
SELECT REPLACE(`NAME`,`小明`,`小刚`) # 将name列下的小明替换为小刚
SELECT STRCMP(`abd`,`lier`) FROM DUAL #逐个字符比较这两个字符串，若前面的字符大于同一位置的后面的字符，则记+1，否则记-1或0，最后返回总和
SELECT SUBSTRING(`NAME`,1,2) FROM `T`# name列下的每一行，从第一个字符开始取，取两个字符
```





#### 4.4 数学函数

数学函数常见以下几种：

| 函数名                        | 功能                        |
| ----------------------------- | --------------------------- |
| ABS（`NUM`）                  | 绝对值                      |
| BIN(`NUM`)                    | 十进制转二进制              |
| CEILING(`NUM`)                | 向上取整                    |
| CONV(`NUM`，`base1`, `base2`) | 将num的进制从base1转到base2 |
| FLOOR(`NUM`)                  | 向下取整                    |
| FORMAT(`num`,`langth`)        | 将num保留langth位小数       |
| HEX(`NUM`)                    | 转16进制                    |



就不再一一举例了，到时候用到再查就行



#### 4.5 日期函数

常用的日期函数有以下几种

| 函数名                                    | 功能                         |
| ----------------------------------------- | ---------------------------- |
| CURRENT_DATE()                            | 获取当前日期                 |
| CURRENT_TIME()                            | 获取当前时间                 |
| CURRENT_TIMESTAMP()                       | 当前时间戳                   |
| DATE(datetime)                            | 返回datetime的日期部分       |
| DATE_ADD(`DATE`, INTERVAL D_value d_type) | 在`DATE`中加上时间或日期     |
| DATE_SUB(`DATE`, INTERVAL D_value d_type) | 在`DATE`中减去时间或日期     |
| DATEDIFF(`DATE1`, `DATE2`)                | 两个日期差，结果以天数显示   |
| TIMEDIFF(`DATE1`, `DATE2`)                | 两个日期差，结果以时分秒显示 |
| NOW()                                     | 当前时间                     |
| YEAR/MONTH/DATE(`DATE`)                   | 得到date中的年或月或日       |
| UNIX_TIMESTAMP()                          | 得到1970-1-1到现在的秒数     |
| FROM_UNIXTIME(TIME（秒）)                 | 将time转成指定格式的日期     |



其使用方法如下

```mysql
SELECT CURRENT_DATE() FROM DUAL; # 得到当前日期 yyyy-mm-dd形式
SELECT CURRENT_TIME() FROM DUAL; # 得到当前时间 HH:MM:SS形式
SELECT TIMESTAMP() FROM DUAL; # 得到当前期间戳 yyyy-mm-dd HH：MM：ss形式
# 以上三种函数也都可以用在添加之中，如
INSERT INTO `T` VALUES(CURRENT_DATE()) # 向表t中添加当前日期

SELECT DATE(DATE_TIME) FROM `T` # 设t表中有一列DATE_TIME是存放时间类型的数据的，则此语法的意思为，将date——time中的时间以年月日的形式显示出来

SELECT * FROM `T` WHERE DATE_ADD(`date_time`,INTERVAL 10 MINUTE) >= NOW() # DATE_ADD函数常见该用法，表示查询表t中所有10分钟内添加的信息
# DATE_SUB语句应用和DATE_ADD应用类似

SELECT DATEDIFF('2022-11-11', '2021-11-11')/365 FROM DUAL  #得到两日期之差，本语句结果是年（因为除了365）
#TIMEDIFF用法类似

#NOW()的应用目前就直接理解为与CURRENT_TIMESTAMP()一模一样就行

SELECT YEAR(NOW()) FROM DUAL #得到当前的年份

SELECT UNIX_TIMESTAMP() FROM DUAL #得到1970-1-1到现在的秒数

SELECT FROM_UNIXTIME(2516565, '%Y-%M-%D %H:%I:%S') # 此处date甚至可以是int类型的数据，然后用该方法转成日期即可
```





#### 4.6 加密函数

常用加密函数有以下几种

| 函数名        | 功能                                                         |
| ------------- | ------------------------------------------------------------ |
| USER()        | 数据库名称                                                   |
| MD5(str)      | 为字符串算出一个MD5形式的32位的字符串，用户密码加密          |
| PASSWORD(str) | 从原文密码str计算并返回密码字符串，通常用于对mysql数据库的用户密码加密 |
| DATABASE（）  | 查询当前使用的数据库的名称                                   |



其使用方法如下

```mysql
SELECT USER() FROM DUAL;  #查看登录到mysql的用户有哪些，以及查看他们登录的ip

SELECT DATABASE() FROM DUAL;  #查看当前使用的数据库是哪个

SELECT MD5('123456') FROM DUAL;  #用此代码得到的结果是一串通过运算得到的字符串，形如：9684sd541a8d4fa5s41654ae，用来再数据库中存放密码，以防止数据库被攻破之后用户的密码暴露

# PASSWORD(STR)也是给加密的，不再展示
```



#### 4.7 流程控制函数

具体函数有以下几种

| 函数名                                                       | 功能                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| IF(expr1,expr2,expr3)                                        | 若expr1为true，则返回expr2，否则返回expr3                    |
| IFNULL(expr1,expr2)                                          | 如果expr1不为null，则返回expr1，否则返回expr2                |
| SELECT CASE WHEN expr1 THEN expr2 WHEN expr3 THEN expr4 ELSE expr5 EDN | 若1为true，则返回2，若3为true则返回4，否则返回5。该表达式只返回一个值，即若返回2了，则不会再判断345了 |



其使用方法如下

```mysql
SELECT IF(TRUE ,'1','2') FROM DUAL #由于expr1为true，故返回expr2，该表达式结果为1

SELECT IFNULL(NULL , '1') FROM DUAL #由于expr1为null，故返回expr2，该结果为1

SELECT CASE WHEN TRUE THEN '1' WHEN FALSE THEN '2' ELSE '3' # 由于expr1为true，故返回expr2，即值为1。之后不再判断
```



#### 4.8 分页函数

若一个表内信息太多，想让其多展几页，如有100行信息，想分两页，每页50行这种。

其语法如下

```mysql
select... #select语句正常写 ... LIMIT start,row
```

该语句表示，再select完了之后，每页从第start+1行开始取，取 row行（如START = 0,ROW = 3，则页里显示第一行、第二行、第三行，共三行）

要注意，该语句为最基础的语句，而mysql也只能一页一页输入，分页约等于是体力活

```mysql
SELECT ... LIMIT 0 , 3; # 第一页从第1行开始存，存三行
SELECT ... LIMIT 3 , 3; # 第二页从第4行开始存，存三行
SLEECT ... LIMIT 6 , 3; # 第三页从第7行开始存，存三行
```



### 5 多表

之前所学的各个语法与函数，都是以应用再单表上为前提的，那多个表时应该怎么办呢？下面会介绍一些有关多表的操作。此章用例为4.2分组查询中所用例子

部门表

| 部门编号 | 部门名称 | 部门位置 |
| -------- | -------- | -------- |
| 10       | 财务部   | 纽约     |
| 20       | 研发     | 北京     |
| 30       | 销售     | 芝加哥   |
| 40       | 业务     | 波士顿   |



员工表

| 员工编号 | 员工名字 | 岗位   | 上司编号 | 工资 | 部门编号 | 入职日期   |
| -------- | -------- | ------ | -------- | ---- | -------- | ---------- |
| 7788     | scoot    | 分析员 | 7566     | 3000 | 20       | 1997-04-19 |
| 7902     | ford     | 分析员 | 7566     | 3500 | 10       | 1991-12-03 |
| 7698     | blake    | 经理   | 7893     | 2850 | 30       | 1991-05-01 |
| 7566     | jones    | 经理   | 7893     | 2957 | 20       | 1991-04-02 |
| 7369     | smith    | 文员   | 7092     | 800  | 20       | 1990-12-17 |
| 7782     | clark    | 经理   | 7893     | 2450 | 10       | 1991-06-09 |
| 7893     | king     | 总经理 | NULL     | 5000 | 10       | 1991-11-17 |



工资级别表

| 工资级别 | 级别最低工资 | 级别最高工资 |
| -------- | ------------ | ------------ |
| 1        | 700          | 1200         |
| 2        | 1201         | 1400         |
| 3        | 1401         | 2000         |
| 4        | 2001         | 3000         |
| 5        | 3001         | 10000        |





#### 5.1 多表查询

多表查询时指基于两个和两个以上的表查询。在实际应用中，查询单个表可能不满足应用需求，就需要用到多表查询。

如在上表中，想查雇员的工资和其所在部门的名称（不是部门编号），就需要用到多表查询，因为部门名称在部门表中，员工工资在员工表中，为两个不同的表。



下面先举例直接查两张表的方法

```mysql
SELECT * FROM '员工','部门'
```

如果这样查，结果是将第一张表的每一行与第二章表的所有行进行拼接显示，若第一张表有x行，第二张表有y行，则就是第一张表的第一行打印y次，第二行打印y次，以此类推，共有x*y行。

这种默认的查询两张表的后的结果，称为笛卡尔集。

其组合后形如

| 7788 | scoot | 分析员 | 7566 | 3000 | 20   | 1997-04-19 | 10   | 财务部 | 纽约   |
| ---- | ----- | ------ | ---- | ---- | ---- | ---------- | ---- | ------ | ------ |
| 7788 | scoot | 分析员 | 7566 | 3000 | 20   | 1997-04-19 | 20   | 研发   | 北京   |
| 7788 | scoot | 分析员 | 7566 | 3000 | 20   | 1997-04-19 | 30   | 销售   | 芝加哥 |
| 7788 | scoot | 分析员 | 7566 | 3000 | 20   | 1997-04-19 | 40   | 业务   | 波士顿 |
| 7902 | ford  | 分析员 | 7566 | 3000 | 20   | 1991-12-03 | 10   | 财务部 | 纽约   |
| 7902 | ford  | 分析员 | 7566 | 3000 | 20   | 1991-12-03 | 20   | 研发   | 北京   |
| 7902 | ford  | 分析员 | 7566 | 3000 | 20   | 1991-12-03 | 30   | 销售   | 芝加哥 |
| 7902 | ford  | 分析员 | 7566 | 3000 | 20   | 1991-12-03 | 40   | 业务   | 波士顿 |
| ...  | ...   | ...    | ...  | ...  | ...  | ...        | ...  | ...    | ...    |



而上述笛卡尔表很明显是不符合正常查询的要求的，因为员工信息对不上，如7788号员工应该只有一个所属部门，但是查询后出来了四条部门，故要添加部分限制来精确查询结果

```mysql
SELECT * FROM '员工','部门' WHERE '员工'.'部门编号' = '部门'.'部门编号' # 用此方法约束一下最终结果，会只显示两表中满足where要求的行。
```

要注意一个衍生问题，观察可以发现，员工表和部门表都有一个列名字叫部门编号，那么这就会导致在查该列时mysql不知道你查的具体时哪个表的部门编号列，故查时也要指明该列所处表是哪个（指明时，用语法为：`表.列名`）

```mysql
SELECT '员工编号','部门编号' FROM '员工表' ,'部门表' WHERE '员工'.'部门编号' = '部门'.'部门编号' # 会报错，因为员工表和部门表都有列：部门编号

SELECT SELECT '员工编号', '员工表'.'部门编号' FROM '员工表' ,'部门表' WHERE '员工'.'部门编号' = '部门'.'部门编号' # 指明部门编号是员工表中的部门编号即可
```



在此基础上，可以更精确的去检索某行了

```mysql
SELECT '员工编号','部门编号' FROM '员工表' ,'部门表' WHERE '员工'.'部门编号' = '部门'.'部门编号' AND '员工'.'部门编号' = 10 # 查找部门编号为10的员工
```



难度再加大一点，如果想显示所有人的 名称、工资、工资级别呢？如下操作

```mysql
SELECT '姓名' ,'工资' ,'工资级别' FROM '员工表' ,'工资级别表' WHERE '工资' BETWEEN '最低工资' ,'最高工资' 
```

在不加约束条件时，每个员工将与5个级别都匹配上，但是只有一种级别是正确匹配的，即匹配的5行中只有一行是对的，要想办法把对的那行找出来。而张两个表的重合信息就是工资，员工的工资总在某个级别的最高工资和最低工资直接，因此，只要筛选出`'工资' BETWEEN '最低工资' ,'最高工资' `即筛选出此员工工资所在的级别，就可以正确筛选出对应的工资级别行了



#### 5.2 自连接

自连接是指将一张表看做两张表来使用。比如想查找员工的姓名和他对应上级的姓名，就需要将员工表当作两张表来看，因为单有一张员工表的话，只能显示员工姓名与其对应上级的编号，无法显示其对应上级的名字。此时用笛卡尔表则需要进行以下操作

```mysql
SELECT 'WORK'.'姓名' AS '下级姓名' , 'BOSS'.'姓名' AS '上级姓名'  # 最终结果显示两列
FROM '员工表' 'WORK' , '员工表' 'BOSS' # 这里查员工表查两次，并将第一个查的员工表命名为work，第二次查的员工表命名为boss
WHERE 'BOSS'.'员工编号' = 'WORK'.'上级编号' # 此处添加约束条件
```



使用自连接时的细节如下：

1、自连接是将同一张表当两张表使用的

2、需要给表起不同的表明

3、最好给列用as取一个标识



#### 5.3 子查询

子查询是指嵌套查询，在一个查询下嵌套另一个查询，这个另一个查询就称为子查询。

总的来说，子查询就是，将一次查询后的结果当作一张新表来再大查询中使用

##### 5.3.1 临时表

> where后

子查询结果可以当作某个条件使用，放在where后面，如下例：

想查询员工表中所有与smith部门相同的员工。

``` mysql
SELECT '姓名' FROM '员工表' WHERE '部门编号' = (
								SELECT '部门编号' FROM '员工表' WHERE '姓名' = 'SMITH') # 用这句话来查询出姓名为smith的员工的部门编号，如结果是20。则最后相当于大SELECT里 WHERE '部门编号' = 20
```



上面展示的是单行子查询，下面举例多行子查询的使用方法

如想查找与部门号为20的员工的工作相同的员工

```mysql
SELECT '岗位' FROM '员工表' WHERE '部门编号' = 20 # 此步骤为查出部门号为20的员工的工作有哪些，结果出来应该是三行：经理、文员、分析员，如果严谨一点，应该再加一个去重的语法，防止有人工作重叠了还都记进去，即在SELECT后面加入DISTINCT

SELECT '姓名' FROM '员工表' WHERE '岗位' IN (SELECT '岗位' FROM '员工表' WHERE '部门编号' = 20) #将上面的查找结果直接拿到where里当约束即可
```



单行子查询一般约束用`=`，因为单行子查询的结果是一个值，用等于来约束；多行子查询的约束一般用`in`，因为多行子查询查出来的是多条结果，相当于给出了一个范围，如上例中给出的就是岗位范围，故用in来约束，只要当前岗位在给出的岗位范围直接就算被选上



> from后

子查询时讲的是将子查询结果放在where中当一个约束条件，临时表类似用法，不过是将子查询表放在`FROM`后面当被查询的表。例子不太好举，就总的来说意思就是，先通过SELECT返回一个结果，然后将该结果当作一个临时表放到FROM后面进行查询。



##### 5.3.2 all、any

具体用法直接看示例就能体会到了，如想显示比部门30里所有员工工资都高的员工姓名

```mysql
SELECT '姓名' FROM '员工表' WHERE '工资' > ALL(SELECT '工资' FROM '员工表' WHERE '部门编号' = 30)
```



如想显示比部门30里其中一个员工的工资高的员工的姓名

```MYSQL
SELECT '姓名' FROM '员工表' WHERE '工资' > ANY(SELECT '工资' FROM '员工表' WHERE '部门编号' = 30)
```



##### 5.3.3 多列子查询

上面所讲的子查询都是返回的单列结果，即SELECT后面只跟了一个列名，这里介绍多列的子查询

以例子来展示，如查询与smith的部门和岗位完全相同的所有雇员，并且不包含Smith本人

```mysql
SELECT '部门','岗位' FROM '员工表' WHERE '姓名' = SMITH # 这里查询SMITH的姓名和岗位，得到结果是两列的

SELECT '姓名' FROM '员工表' WHERE ('部门' ,'岗位') = (SELECT '部门','岗位' FROM '员工表' WHERE '姓名' = SMITH) #多列子查询用法就是这样
AND '姓名' != 'SMITH' # 最后的约束条件
```



##### 5.3.4 子查询练习

针对上述介绍的各种子查询方法，有两道题来综合练习一下

1、查询工资大于本部门平均工资的人的名称、部门、工资、与部门平均工资

```mysql
 SELECT '部门编号'、AVG('工资') FROM '员工表' GROUP BY '部门编号' # 先查出各个部门的平均工资，然后让该表作为一个临时表放到FROM后面进行查询
 
 SELECT '姓名','员工表'.'部门编号','员工表'.'工资' ,'temp'.'AVG_SAL' FROM '员工表', (SELECT '部门编号'、AVG('工资') AS 'AVG_SAL' FROM '员工表' GROUP BY '部门编号') TEMP # 将该临时表命名为temp
 WHERE '员工表'.'工资' > 'TEMP'.'AVG_SAL' AND '员工表'.'部门编号' = 'TEMP'.'部门编号'
```



2、查询每个部门的信息：部门编号、部门名称、部门地址、部门人员数量

```mysql
SELECT COUNT(*) FROM '员工表' GROUP BY '部门编号' # 将各个部门里有多少人先统计出来

SELECT '员工表'.'部门编号','员工表'.'部门名称','员工表'.'部门地址','temp'.'人员数量' FROM '部门表',(SELECT COUNT(*) AS '人员数量' FROM '员工表' GROUP BY '部门编号') TEMP WHERE '部门表'.'部门编号' = 'temp'.'部门编号'
```



##### 5.3.5 表复制与去重

> 复制

表复制可以分为将其他表复制过去或者表的自我复制

先说将其他表复制到新表。首先要有一个新表，新表的列数要与被复制的表的列数相同（列名可以不同），然后用`INSERT INTO`语句进行复制，复制时，不需要输入`VALUES`了

```mysql
CREATE TABLE TALBE_TEMP (
'NAME' VARCHAR(32)
'SAL' INT(32)
'DEPTNO' INT(32)
) # 做一个空表，里面定义一些列

INSERT INTO TABLE_TEMP ('NAME' , 'SAL' , 'DEPTNO') SELECT '姓名' ,'工资' ,'部门' FROM '员工表' # 直接用该语句将老表复制到新表
```



表的自我复制。表的自我复制语法跟上面一样，其结果为，若表本来有1行，则复制完之后有两行，再复制则有4行，以此类推

```mysql
INSERT INTO TABE_TEMP  SELECT FROM TABE_TEMP # 这里如果是将新表全部行都赋值的话，是不需要特地指定哪几列的，也不用使用*，直接写表名就行了
```



表复制还有一种特殊的复制方法--只复制表结构而不复制表数据的方法，即被复制的表里有几列，新表就有几列；被复制的表里列名分别是什么，新表的列名就是什么

```mysql
CREATE TABEL '员工表1' LIKE '员工表' # 此时员工表1为新表，其结构和员工表一模一样，都有员工编号、员工姓名、部门编号等列，但是员工表1是没有具体数据的，即行数为0.
```



> 去重

上面说完了表复制，现在介绍如何给表去重

先做一张有重复的表

```mysql
CREATE TABEL '员工表1' LIKE '员工表' # 先复制结构
INSERT INTO '员工表1' SELECT * FROM '员工表' # 将老表的所有列都赋值给新表
INSERT INTO '员工表1' SELECT * FROM '员工表' #再复制一次，此时新表只有一半的数据是有价值的，另一半是重复的信息
```

下面操作如何给员工表1去重



表的去重思路如下：

1、先创建一张临时表MY_TEMP

2、将员工表1的数据通过distinct关键字（用于去重的关键字）处理后复制给临时表

3、将员工表1清空

4、将临时表数据全部再复制回员工表

5、删除临时表

```mysql
CREATE TABLE MY_TEMP LIKE '员工表1' # 1、临时表创建

INSERT INTO MY_TEMP SELECT DISTINCT * FROM '员工表1' # 2、将员工表1通过distinct关键字处理后复制给临时表

DELETE FROM '员工表1' # 3、将工表1数据删除

INSERT INTO '员工表1' SELECT * FROM 'MY_TEMP' # 4、将临时表的数据全部复制进员工表中

DROP TABLE MY_TEMP # 5、将临时表删除 
```



为什么要这么麻烦呢？为什么不能直接在原表中distinct呢?因为在原表中用distinct的语法如下

```mysql
SELECT DISTINCT * FROM '员工表1' 
```

该语法只是将查询结果去重了，并没有对原表进行什么操作，故起不到表去重的目的



#### 5.4 外连接

> 引出

在之前的所有查询学习时，会发现40号部门的出镜率非常低，甚至没有出现过，这是以为40号部门没有员工，故用常规的select语句查询员工信息时查询不出来有关40号部门的情况。那么该如何按照部门来查询出每个部门下的员工信息（即使部门底下没有员工也显示出来）呢？

用常规的select语句只能做到如下情况

```mysql
SELECT '员工表'.'员工姓名', '员工表'.'部门编号', '部门表'.'部门名称' FROM '员工表','部门表' WHERE '员工表'.'部门编号' = '部门表'.'部门编号' ORDER BY '部门表'.'部门编号'
```

用该方法查出来的结果为

| 员工姓名 | 部门名称 | 部门编号 |
| -------- | -------- | -------- |
| frod     | 财务部   | 10       |
| clack    | 财务部   | 10       |
| king     | 财务部   | 10       |
| scort    | 研发部   | 20       |
| Jones    | 研发部   | 20       |
| smith    | 研发部   | 20       |
| blake    | 销售部   | 30       |

会发现上面并没有40号部门的任何信息，而此次查询想得到的效果是，哪怕40号部门没有员工，也要有40号部门的基本信息，即如下效果

| 员工姓名 | 部门名称 | 部门编号 |
| -------- | -------- | -------- |
| frod     | 财务部   | 10       |
| clack    | 财务部   | 10       |
| king     | 财务部   | 10       |
| scort    | 研发部   | 20       |
| Jones    | 研发部   | 20       |
| smith    | 研发部   | 20       |
| blake    | 销售部   | 30       |
|          | 业务部   | 40       |

此时需要用外连接的相关技术来实现



> 基本介绍

实际上前面所讲的各种多表查询都称为内连接，实际应用中还是内连接用的多。外连接一般只用来处理内连接处理不了的情况。

外连接分为两种：

1、左外连接：在查询多表时，如果左侧的表完全显示，称之为左外连接

2、右外连接：在查询多表时，如果右侧的表完全显示，称之为右外连接

```mysql
SELECT * FROM '员工表','部门表'
# 如果想让员工表全部显示，则称为左外连接；如果想让部门表全部显示则称为右外连接
```



想实现上面想要的查询结果，需要用到右连接的意思（左右不是固定的，如果把部门表写到左边则用左外连接）



> 左右外连接

其基本语法如下

```mysql
SELECT * FROM 'TABLE1' LEFT JOIN 'TABLE2' ON 'TABLE1'.'***' = 'TABLE2'.'***'(任何条件都行)  # 此为左连接，会将table1的数据全部显示出来，即使table1的***信息和talbe2的***信息对不上号。也就是说表二迁跟着表1走，表1显示的表二跟在后面可以有数据也可以是null，但是表1没有信息可显示了表二一定也不能再显示了

SELECT * FROM 'TALBE1' RIGHT JOIN 'TABLE2' ON 'TABLE1'.'***' = 'TABLE2'.'***'(任何条件都行) # 此为右连接，TABLE1跟着TABLE2走
```



此时想实现显示出全部部门的信息就可以如下操作了

```mysql
SELECT * FROM '部门表' LEFT JOIN '员工表' ON '员工表'.'部门编号' = '部门表'.'部门编号' GROUP BY '部门表'.'部门编号'
```





### 6 约束

约束用于确保数据库的数据满足特定的商业规则。在mysql中，约束包括：primary key（主键）、unique（唯一）、foreign key（外键）、check（检查）、not null（非空）五种



#### 6.1 PRIMARY KEY(主键)

> 语法

主键是在表创建时，用来限制列的，当定义主键约束后，该列的值不可以重复。其基本语法如下

```mysql
CREATE TABLE TABLE_1 ('ID' INT PRIMARY KEY) # 新建一个表，该表中有一个id列，并且该列用主键进行约束

INSERT INTO TABLE_1 VALUES(1) # 将数值1记录进表的id列中的第一行，可以成功
INSERT INTO TABLE_1 VALUES(2) # 将数值2记录进表的id列中的第二行，可以成功
INSERT INTO TABLE_3 VALUES(1) # 将数值1记录进表的id列中的第三行，由于id列被primary key约束了，不能存入相同的值，故记录失败，报错
```



> 细节

primary key约束的列不能有重复值，也不能有空值

一张表最多只有一个主键，但是可以是复合主键。所谓复合主键，就是将若干个列同时设为主键，然后如果这些列在添加行时同时重复了，就会添加失败

```mysql
CREATE TALBE `TEMP` ('ID' INT, 'NAME' VARCHAR(32)), PRIMARY KEY('ID' , 'NAME')) # 将id和name都设为主键

INSERT INTO `TEMP` VALUES(1,'HE') # 添加第一组数据，1添加进id、`HE`添加进`NAME`
INSERT INTO `TEMP` VALUES(1,'LI') # 添加第二组数据，1添加进id，`LI`添加进`NAME`,可以添加成功，因为虽然1和第一组数据重复了，但是name的数据没有重复
INSERT INTO `TEMP` VALUES(1,'HE') # 添加失败，该数据的两列与第一组数据完全重合，不满足主键的约束了，故添加失败
```



#### 6.2 NOT NULL (非空)

非空约束前面已经接触过了，前面接触的也就已经时非空的全部用法。当定义某个列为非空后，传入该列的数据不可为空

```mysql
CREATE TALBE 'TAB' ('ID' INT NOT NULL, 'NAME' VARCHAR(32) NOT NULL) # 将id列和name列同时设置为非空

INSERT INTO 'TAB' (NULL,NULL) # 添加失败，必须得向id列和name列传值才行
```

非空不是唯一的，可以给表中的多个列设置非空



#### 6.3 UNIQUE(唯一)

当定义了唯一约束后，该列的值是不能重复的。唯一的功能和主键几乎一样（不一样的地方在于主键不能有空，唯一可以有空），但是唯一可以多次设置，而主键只能设置一次。

```mysql
CREATE TABLE 'TAB' ('ID' INT UNIQUE, 'NAME' VARCHAR(32)) # 将id列设置成唯一

# 其使用方法和主键一样，不再展示
```



> 细节

某列使用unique约束后，若没有将该列设为not null（非空），则该列是可以传入null的，并且可以传入多个null。如果不想让唯一有空，可以同时下唯一和非空两个约束

```mysql
CREATE TABLE 'TAB' ('ID' INT UNIQUE NOT NULL) # id列既是唯一又是非空
```



#### 6.4 FOREIGN KEY(外键)

外键用于定义主表某列和从表某列之间的关系：外键约束要定义在从表的某列上，主表对应的列则必须有主键约束或者唯一约束。当定义外键约束后，要求外键列数据必须在主表的主键列存在或是为null。

> 效果

比如有下两表



学生信息表

| 姓名 | 班级编号 |
| ---- | -------- |
| 小明 | 01       |
| 小红 | 02       |



班级信息表

| 班级编号 | 班级地址 |
| -------- | -------- |
| 01       | 北京     |
| 02       | 上海     |



如果要求在学生表里记录新学生时，学生所在的班级号必须是班级信息表里存在的班级号，则可以把学生表里的班级编号设为外键

```mysql
# 想达到的效果为
INSERT INTO '学生信息表' VALUES('小刚' ,03) # 让该语句添加失败，因为不存在班级编号为03的班级
```

当把学生信息表当为班级信息表的从表并对班级编号做外键约束后，在主表中即班级编号表中对班级编号中已经与学生信息表班级编号中有关联的行进行删除时会删除失败

```mysql
# 假设现在已经做好外键约束了
DELETE FROM '班级信息表' WHERE '班级编号' = 02 # 会删除失败，因为现在学生信息表里已经有02号班级了，想让该语句成功，就要将学生信息表里不存在班级编号为02的行，即把小红行给删掉，才能在班级信息表中将02号班级删掉
```



> 语法

外键约束的语法如下

```mysql
FOREIGN KEY ('本表列名') REFERENCES '主表名（主键列名/唯一列名）'
```

以上表为例，将班级信息表视为主表，学生信息表视为从表

```mysql
CREATE TABLE '班级信息表' ('班级id' INT PRIMARY KEY , '班级地址' VARCHAR(32)) # 初始化主表，并将主表中班级id列设为主键
CREATE TABLE '学生信息表' ('学生姓名' VARCHAR(32) NOT NULL , '所在班级' INT , FOREIGN KEY ('所在班级') REFERENCES '班级信息表'('班级id')) #将学生信息表中的`所在班级`列与班级信息表中的`班级id`列进行外键关联

INSERT INTO '班级信息表' VALUES (01 , `北京`),(02,'上海') # 向班级信息表里添加两个数据

INSERT INTO '学生信息表' VALUES('HE' , '01') # 添加成功
INSERT INTO '学生信息表' VALUES('LI' , '02') # 添加成功
INSERT INTO '学生信息表' VALUES('HE' , '03') # 添加失败，因为该列通过外键关联的班级信息表中的班级id列里，并没有03这个数据，故无法添加

DELETE FROM '班级信息表' WHERE '班级id' = 01 # 删除失败，因为与该列通过外键关联的学生信息表中的所属班级里，存在01这个数据，故无法删除
```

 

> 细节

1、外键指向的表的列，必须时primary key列或者unique列

2、从表的类型要是innodb，这样才支持外键

3、外键字段的类型和主键字段的类型要一致，长度可以不一样，如都得是VARCHAR，但是主键是VARCHAR(32)，外键是VARCHAR(64)，是可以成立的

4、外键字段的值，必须在主键字段里存在，或者外键值为null（前提是外键列允许为null）

```mysql
INSERT INTO '学生信息表' VALUES('小刚' ,'NULL') # 当学生信息表中的所在班级列没有限制不能为空时，该语句是可以成立的
```

5、一旦建立主外键的关系，数据就不能随意删除了



#### 6.5 CHECK(检查)

检查约束是用于强制让被约束的列中所有数据满足条件。比如将学生信息表中的所在班级列进行检查约束，约束为01~05，这样如果有不在01~05号班级的学生就想添加进去，就会报错。其语法为

```mysql
CREATE TABLE *** ('列' 数据类型 CHECK (约束条件))
```



如

```mysql
CREATE TABLE 'test' ('ID' INT PRIMARY KEY,
                    'NAME' VARCHAR(32) NOT NULL
                    'SEX' VARCHAR(6) CHECK ('SEX' IN('MAN','WOMAN')) # 对性别类进行约束，若新信息想添加进test表，则其性别列必须为MAN或WOMAN
                    )

INSERT INTO 'TEST' VALUES (1,'HE','MAN') # 成功添加
INSERT INTO 'TEST' VALUES (2,'WU','MAN1') # 添加失败，因为man1不再chack条件里
```



> 细节

mysql5.0系列目前还不支持check的实际使用，它虽然可以定义check列，但是只是个样子，是没有约束效果的。



#### 6.6 自增长

自增长实际上不是约束了，但是其语法和约束相关，故就在这里介绍一下。

自增长的效果如下：在某张表中，存在一个列（该列必须为整型），如果每次向表里添加记录时，该列能从1开始自动增长，则该列称为自增长列

其语法如下

```mysql
CREATE TABLE *** ('列' INT PRIMARY KEY AUTO_INCREMENT)
```



其使用如下

```mysql
CREATE TABLE 'TAB' ('ID' INT PRIMARY KEY AUTO_INCREMENT
                   'NAME' VARCHAR(32) NOT NULL) # 创建一个表，里面id列设为自增长列，name列设为非空列

INSERT INTO 'TAB' VALUES('HE') # 可以直接跳过id进行赋值，首次添加数据时id默认为1
INSERT INTO 'TAB' VALUES('LI') # 再次添加后，该行id为2
# 再添加id就是3
                   
              
```



> 细节

自增长的起始值可以自定义 ，用如下语句

```mysql
ALTER TABLE *** AUTO_INCREMENT = *** # 将表的静态属性（可以这么理解）设为***
```



自增长一般配合主键使用，不配合主键用时也要配合唯一用



自增长的修饰字段一定为整型（极个别为小数）



自增长也可以在传入数据时指定初始值，该优先级最高

```mysql
CREATE TABLE 'TAB' ('ID' INT PRIMARY KEY AUTO_INCREMENT
                   'NAME' VARCHAR(32) NOT NULL) # 创建一个表，里面id列设为自增长列，name列设为非空列
ALTER TABLE 'TAB' AUTO_INCREMENT = 100 # 将表的自增长属性初始化为100

INSERT INTO 'TAB' VALUES('HE') # 可以直接跳过id进行赋值，此时id为100
INSERT INTO 'TAB' VALUES('10','HE') # 此时指定自增长属性为10，故为10。并且如果之后不再传入自增长值，则自增长值会从10开始，若再传入，则以传入为准

```



### 7 索引

在一个表里的数据还不多时，用select语句进行查询可以很快的查出结果。但是数据库数据量上来之后，再进行查询会发现慢了很多。为了应对这种情况，就需要在表里创建一个索引来提高查询速度。

先提前强调一点，在表里创建的索引是占用存储空间的，每创建一个索引就多占一点存储空间。而且创建的索引是针对列的，只在查找创建了索引的列上的数据时会变快，查找其他没有加索引的列速度还是很慢。总的来说，创建索引就是牺牲空间换取时间。



在没有索引时，对表进行查询需要将表进行一次遍历，可以理解为在没有添加索引时，数据库的查找机制和链表的查找机制类似，在对某列创建了索引后，是将该列的数据以二叉树的形式存储起来，比如有10个数据，正常查找需要比较10次，而将其添加到索引后，其以三层的二叉树形式存储，最多只比较3次就行了。

相对的，创建完索引后，其增删改都会变得稍微慢点，因为对二叉树的这三种操作都是费点劲的。



#### 7.1 索引创建（增）

索引分为四种类型：主键（primary key）索引、唯一（unique）索引、普通索引（index）、全文索引（fulltext）。下面逐一介绍四种索引



```mysql
CREATE TABLE 'TAB' ('ID' INT,
                   'NAME' VARCHAR(32)
                   ) # 创建一张表

CREATE UNIQUE INDEX 'id_unique_index' ON 'TAB'('ID') # 唯一索引的创建语法，CREATE UNIQUE INDEX '索引名称' ON '表名'（'列名'）


CREATE INDEX 'id_index' ON 'TAB'('ID') # 普通索引创建语法1，CREATE INDEX '索引名称' ON '表名'（'列名'）
ALTER TABLE 'TAB' ADD INDEX 'id_index'('ID') # 普通索引创建语法2，ALTER TABLE '表名' ADD INDEX '索引名'('列名')

ALTER TABLE 'TAB' ADD PRIMARY KEY('ID') # 主键索引，主键索引比较特殊，主键默认就是一个索引，即给一个列定义主键后，该列就已经是一个索引了。其索引名就是`PRIMARY`。
# 由于主键就是索引，故创建表时定义列的时候，就可以直接将列设为主键从而让其变为主键索引：(`ID` INT PRIMARY KEY)，将id列设为主键，其自带索引

#全文索引一般不用，不细说了
```



#### 7.2 索引的删改查

删除索引前要知道该表有哪些索引，故先要会查找索引

> 查看索引

```mysql
SHOW INDEX FROM 'TAB' # 语法为 SHWO INDEX FROM '表名'
```

查看后，会将表内哪列有索引，索引叫什么名字都显示出来



> 删除索引

删除索引用如下语句

```mysql
DROP INDEX 'id_index' ON 'TAB' # 语法为 DROP INDEX '索引名' ON '表名' （该语句用来删除除主键索引外的索引）

ALTER TABLE 'TAB' DROP PRIMARY KEY # 删除主键索引的方法为这个，直接删除指定表里的主键即可
```



> 修改索引

修改某列的索引就是先将该列索引删除再添加索引就行



### 8 事务

事务用于保证数据的一致性，它由一组相关的语法组成，该组的语句要么成功，要么全部失败。



这样做能有个好处，拿个实例举例：

数据库表里有两个人，a有3000块钱，b有5000块钱。现在想让b转1000块给a，用之前学过的知识是这样干

```mysql
UPDATE '表名' SET MONEY = MONEY - 1000 WHERE MONEY = 5000 # 将b的钱减1000
UPDATE '表名' SET MONEY = MONEY + 1000 WHERE MONEY = 3000 # 将a的钱加1000
```

这里如果两句话都没有出错还好，如果都出错了也不过是转账失败，但是，如果只有b减钱语句执行成功了，而a加钱的语句执行失败了，那就问题大了。

故此时可以用事务来避免这种情况的发生。



当执行事务操作时，MySQL会在表上加锁，防止其他用户改表的数据。



#### 8.1 事务操作

> 语法

事务的流程基本如下：START TRANSACTION(开始事务) --> SAVEPOINT(设置保存点) --> COMMIT(提交事务)。其中在提交事务之前，可以通过ROLLBACK TO(回退事务)来撤销一部分操作，从保存点再来一遍。

```mysql
CREATE TABLE 'TAB' ('ID' INT
                   'NAME' VARCHAR(32))

START TRANSACTION # 开始事务

SAVEPOINT 'a' # 设置保存点，将该保存点命名为'a'

INSERT INTO 'TAB' VALUES(100,'HE') # 进行正常的数据库操作

SAVEPOINT 'B' # 设置第二个保存点，命名为'B'

INSERT INTO 'TAB' VALUES (200,'LI') # 进行正常的数据库操作

# 不想添加第二组数据了，想回退，可以用ROLLBACK TO 语句回退
ROLLBACK TO 'B' # 将表回退到事务保存点'B'处

# 若想再撤销一组数据添加，也可以再次回退到保存点'A'
ROLLBACK TO 'A'

# 若不指定回退到哪，只用ROLLBACK，则是直接回退到事务开始处，并且自动删除中间所有的保存点（跳保存点回退也会把跳过的保存点删除，如直接从最后回退到a，则b保存点也自动删除，就无法再回退到b了）

COMMIT # 提交事务，提交后，之前的事务内各种数据库操作生效，无法进行回退，因为commit后会自动删除所有保存点。
```



> 细节

1、如果不开启事务，正常执行mysql语句是自动commit的，不能回退（就是正常的mysql操作，每操作一步都进行一次提交，使操作生效）

2、如果开始一个事务，但是没有创造保存点，则使用ROLLBACK回退会回退到开始事务的地方，将事务中的操作全部撤回。

3、想使用事务操作得要求表是innoDB的存储引擎

4、开始事务的语句除了START TRANSACTION 之外，还可以用SET AUTOCOMMIT=OFF。



#### 8.2 隔离级别

##### 8.2.1 概念

若数据库被多个用户同时连接，则各个连接在开启各自事务操作时，数据库系统要负责隔离操作，以保证各个连接在获取事务的准确性。

举个例子通俗解释一下：有a和b两个用户同时连接同一个数据库的同一个表，a在对表进行某种操作（增删改查等等），此时b能看到的表的内容要根据b的隔离级别来确定，比如b的权限很牛逼，那就能看到a的每一步实时操作后的数据库，但是如果b的级别不太行，那可能得等a操作完才能看见更改后的表，否则一直看的是a操作前的表。



如果不考虑隔离性，可能会引发如下问题：

1、脏读：当一个用户在操作数据库并且还没有提交事务时被另一个用户读到数据库了，则称为脏读

2、不可重复读：同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果，此时称为不可重复读。有点抽象，先凑合理解

3、幻读：在同一事务中进行多次查询，但是由于其他事务提交了插入操作，导致本事务的各个查询结果是不一样的，称为幻读



而事务隔离级别则定义了事务与事务之间的隔离程度，其可总结为下表

| 隔离级别                     | 脏读 | 不可重复读 | 幻读 | 加锁情况 |
| ---------------------------- | ---- | ---------- | ---- | -------- |
| 读未提交（Read uncommitted） | √    | √          | √    | 不加锁   |
| 读已提交（Read committed）   | ×    | √          | √    | 不加锁   |
| 可重复读（Repratable read）  | ×    | ×          | ×    | 不加锁   |
| 可串行化（Serializable）     | ×    | ×          | ×    | 加锁     |

（√为可能出现，×为不会出现）

默认的隔离等级时可重复读。

上表中从上到下隔离级别从弱到强，读未提交隔离级别最弱，它脏读、不可重复读、幻读都可能出现，可串行化隔离级别最强，它三种错误读法都不会出现。下面具体举例详细说明



有ab两个用户，他们同时连接了一张空表并同时开始事务。理想情况是：a和b在各自事务还没有提交前，都只操作该空表，等各自都提交结束后，才看到经过共同修改后的表。下面分别说明三种错误读法的情况：1、脏读，把b的隔离等级设为最低隔离级别：READ UNCOMMITTED(读未提交)，a开启事务后向表内添加信息，并且先不提交，此时b在事务中对该表进行查询会查询处a尚未提交的信息。 2、不可重复度、幻读。此处把这两种读法一起来说，因为这两种读法都是跟提交事务相关的。假设a向刚刚添加进表的信息进行一次修改，并再次添加一条信息，之后进行提交事务。b再次在事务中查询该表，会发现a刚刚进行的所有操作，其中发现a的修改操作是不可重复读，发现a的添加操作是幻读。理论上，在b没有提交事务前，b查找表应该只能看见空表才行，而刚刚查找发现的各种信息，应该在b提交事务后才能看见

随着b的隔离级别上升，三种错误读法会逐渐消失。

最后再说明一下可串行化，给b设置隔离级别为可串行化，然后当a事务在操作同一个表时，b事务无法对表进行任何操作（增删改查），当试图操作时，数据库会卡在指令输入行，不会往下继续进行，直到a事务提交结束。



实际上所谓的隔离级别高，另一种看法就是自身权限小，隔离级别越高自身的权限就越小，当隔离级别最低时，哪怕别人事务都没提交自己都能看见；当隔离级别最高时，别人在操作数据库自己甚至都不能查看空表。



##### 8.2.2 操作

下面介绍隔离级别的各种操作方法

```mysql
SELECT  @@tx_isolation;  # 查看当前会话隔离级别

SELECT @@global.tx_isolation # 查看当前系统隔离级别

SET session transaction isolation level XXX # 设置当前会话隔离级别

SET global transaction isolation level xxx; #设置当前系统隔离基本
```

当前会话隔离级别是各个连接进数据库的用户的隔离级别；当前系统隔离级别是每个连接进数据库的用户的隔离级别



一般情况下隔离级别是不用修改的，因为可重复读隔离级别已经足够用了。



##### 8.2.3 事务特性

1、原子性（Atomicity）

原子性是指事务是一个不可分割的工作状态，事务中的操作要么都发生，要么都不发生



2、一致性（consistency）

事务必须使数据从一个一致性状态变换到另一个一致性状态

通俗解释就是说，表中的数据会从事务开始前的状态变为事务提交后的状态



3、隔离性（isolation）

就是刚刚将的隔离



4、持久性（durability）

持久性是指一个事务一旦被提交，它对数据库的改变就是永久的，接下来数据库就无法撤回该操作了（是无法撤回，可以删除等等操作）





### 9 视图

#### 9.1 概念

目前有一个表，里面有员工的各种信息，包括一些常规信息：姓名、年龄等，也包括一些隐私信息：身份证号等。在别人查表时，只希望他能看见表里的常规信息，而看不到表里的隐私信息，此时可以用视图来处理该表。

视图是一个虚拟表，其内容来自基表，也就是说视图里没有实体内容，不占存储空间，他只是基表的内容映射。视图的数据是来自对应的真实表，该真实表称为基表。视图所根据的基表可以有多个。

对视图的各种操作会反馈给基表，使基表进行对应的操作。由于视图的原理，对基表的操作也必然会对视图进行更改。



可以在视图中再次开启视图。



#### 9.2 操作

视图的基本使用方法如下

```mysql
CREATE VIEW '视图表' AS SELECT '列1','列2','列3' FROM '基表'  # 创建视图表，指定该视图表的基表是谁，并指定该视图表展示基表里的哪几列

CREATE VIEW '视图表' AS SELECT '列1','列2',,, FROM '基表1','基表2',, # 视图继承多个基表的语法

DROP VIER '视图表' # 删除视图表
```

在创建完视图后，就可以将视图视为一个常规表一样，对视图进行各种增删改查



#### 9.3 特性

1、安全

有些数据表有着重要的信息，这些信息是保密的不能让用户看见。此时就可以用视图来管理一下这个表



2、性能

关系数据库的数据常常会分表存储，使用外键建立这些表之间的关系。这时数据库查询通常会用到连接（join）。这样做不但麻烦，效率也低。如果建立一个视图，将相关的表和字段直接用视图组合在一起，就可以避免这种麻烦



3、灵活

如果系统中有一张旧的表，由于该表的设计问题即将报废，然而很多应用都是基于该表的，不易更改。此时可以用视图将数据直接映射到新建的表中，这样可以减少很多改动，达到升级表的目的。



### 10 用户管理

同一个数据库可以有多个不同的用户进行访问，对这些用户进行管理也是重要的事情，如针对不同的工作，给不同的用户对应的权限。



mysql中的用户信息，都存储在mysql中的user表中，该表中有以下几列相对重要：

host列：host列指明了允许用户登录的位置，若某用户的该行数据为'localhost'则表明该用户只允许本机登录。该列的数据也可是ip地址等其他数据

user列：用户名

authentication_string：用户密码，通过mysql的password（）函数加密后存放在该表中



#### 10.1 用户操作

```mysql
CREATE USER '用户名' @ '登录地址' IDENTIFIED BY '密码' # 新创建用户，指定用户名、用户登录地址、用户密码

DROP USER '用户名' @ '登录地址' # 删除用户

SET PASSWORD = PASSWORD('新密码') # 修改自己的密码

SET PASSWORD FOR '用户名'@ '登录地址' = PASSWORD('新密码') # 修改别人的密码（需要有对应用户的权限）
```

一个新的用户，登录进mysql后，能操作的数据库、表、视图是根据自身权限来确定的。



#### 10.2 权限管理

新建一个用户后，要给这个用户对应的权限，下面讲一下赋权操作（赋权一般在root用户上进行，因为root用户权限最高）

```mysql
GRANT '权限列表' ON '库.对象名' TO '用户名' @ '登录地址'
```

对上面的名词一一进行说明

1、权限列表：指明该用户可以获得什么权限（增删改查）

```mysql
GRANT SELECT, DELETE, CREATE ON ... # 赋予用户查、删、增的权限
GRANT ALL ON... # 赋予用户所有操作数据库的权限
```



2、库.对象名

该权限是指给用户操作哪个表的权限，对象名可以为表、视图、存储过程等等。

```mysql
ON '数据库名'.'对象名' # 指明给的哪个位置的权限
ON '数据库名'.* # 将某数据库下的所有对象的权限开放
ON *.* # 将所有数据库的权限开放
```



当觉得某个用户可以不用某个权限了，可以进行回收

```mysql
REVOKE '权限列表' ON '库.对象名' TO '用户名' @ '登录地址'
```



### 11 JDBC

#### 11.1基础介绍

JDBC为访问不同的数据库提供了一个统一的接口，为使用者屏蔽了部分细节问题。

java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。

实际上JDBC规范了一套接口，只有实现了该接口的数据库系统（数据库公司如：mysql、Oracle等数据库）才能被java调用。

这些驱动是一个".jar"的文件。

java程序员只需要面向这套接口编程就行，不需要额外的对各个厂商进行各自的匹配，会方便很多。

下面模拟一下jdbc的工作方式

```java
/**
 * 假设自己是java厂商，模拟一下java提供的jdbc接口
 */
public interface _01_JDBCInterfacce {

    public Object getConnection();

    public void close();

}

/**
 * 模拟一下数据库厂商实现jdbc接口的过程
 */
public class _02_mysqlJDBC implements _01_JDBCInterfacce{

    @Override
    public Object getConnection() {
        System.out.println("连接数据库");
        return null;
    }

    @Override
    public void close() {
        System.out.println("关闭数据库");

    }
}

/**
 * 模拟Oracle数据库实现jdbc
 */
public class _03_OracleJDBC implements _01_JDBCInterfacce{
    @Override
    public Object getConnection() {
        System.out.println("Oracle连接");
        return null;
    }

    @Override
    public void close() {
        System.out.println("Oracle关闭");

    }
}


/**
 * 此处模拟在java程序中调用数据库的过程
 */
public class _04_run {
    public static void main(String[] args) {
        //在java中直接实例化数据库对象（通过java提供的接口实现）
        _01_JDBCInterfacce jdbcInterfacce = new _02_mysqlJDBC();
        _01_JDBCInterfacce jdbcInterfacce1 = new _03_OracleJDBC();
        //通过多态绑定到数据库提供的方法
        jdbcInterfacce.getConnection();
        jdbcInterfacce.close();

        jdbcInterfacce1.getConnection();
        jdbcInterfacce1.close();

    }
}
```



#### 11.2 JDBC程序编写步骤

1、注册驱动：加载Driver类

2、获取连接：加载Connection方法

3、执行增删改查：发送sql命令给mysql执行

4、释放资源：关闭相关链接



下面通过示例来逐步演示

在操作代码前，要去下载驱动，将驱动中的-bin.jar这个后缀的文件放入项目包下，然后右键该文件选择add as library将其引入到当前项目中。

```java
public class run {
    public static void main(String[] args) throws SQLException {

        //1、注册驱动
        //引入mysql提供的jar文件。

        //创建一个driver对象
        // 此处要注意，该driver对象是正常类的对象，不是接口对象，在系统自动补齐时要选对
        Driver driver = new Driver(); 

        //2、得到链接
        //jdbc:mysql:// 这部分时固定的，一般不动；localhost是直接连接到本地，这部分是存放IP地址的；3306表示mysql所在的端口；最后的mysql是具体连接哪个数据库
        String url = "jdbc:mysql://localhost:3306/jdbc_study";

        //将用户名和密码放到properties对象中（properties是配置流对象，io的时候讲过）
        Properties properties = new Properties();
        //下面是一些数据库的必须信息，key值都是固定好的，别拼错了
        properties.setProperty("user","root");//
        properties.setProperty("password","123456hlh789");

        //获取连接
        Connection connect = driver.connect(url,properties);//该方法接受一个url地址，再接受一个配置流，返回一个Connection对象


        //3、执行增删改查
        //直接将要使用的sql语句做成String字符串，到时候直接用进去
        String sql = "insert into chapter1 values(01,'tom','m','123456789012')";

        //做一个Statement对象，该对象用来操作sql的静态语句然后返回该语句的执行结果
        Statement statement = connect.createStatement();
        int rows = statement.executeUpdate(sql);//该方法是接受一个sql语句来执行，返回一个int值，该值表示数据库中受影响的行数

        System.out.println(rows > 0 ? "成功" : "失败");


        //4、关闭链接
        statement.close();
        connect.close();
    }
}
```

上面程序中，出现了多个对象，下面解释一下

Driver对象，用来调用其connect方法，接受数据库地址和数据库的配置文件，返回一个connect对象

connect对象，实际上就代表这java和数据库直接的链接，即将java和数据库直接打通了，可以传输内容了，但是该链接本身并没有方法来传输数据，要通过其提供的createStatement方法来返回statement对象。

statement对象是专门用来执行sql语句的对象，其内部有各种方法，来接受一个String字符串（该字符串内写好了要执行的且可以通常执行的sql语句），接受完该语句后通过connect将语句传入到数据库中进行执行，并返回各种特定的值来判断执行的效果。



最后要关闭执行语句的对象和连接对象



#### 11.3 java连接数据库的方式

上面介绍jdbc使用时，用的是第一种java连接数据库的方法，其通过Driver对象进行连接，但是该Driver对象实际上是通过"com.mysql.jdbc.Driver"这个包下的静态属性来引入的对象，使用起来可能会有些限制。下面介绍一些其他方式进行数据库的连接

```java
public class _02_connectTipe2 {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, SQLException {
        Class<?> aClass = Class.forName("com.mysql.jdbc.Driver");
        Driver driver = (Driver) aClass.newInstance();

        String url = "jdbc:mysql://localhost:3306/jdbc_study";

        Properties properties = new Properties();
        properties.setProperty("user","root");
        properties.setProperty("password","123456hlh789");

        Connection connection = driver.connect(url,properties);
        System.out.println(connection);

        connection.close();
    }
}
```



```java
public class _03_connectTipe3 {
    public static void main(String[] args) throws SQLException {
        Driver driver = new Driver();

        String url = "jdbc:mysql://localhost:3306/jdbc_study";

        Properties properties = new Properties();
        properties.setProperty("user","root");
        properties.setProperty("password","123456hlh789");

        DriverManager.registerDriver(driver);//注册Driver驱动,但是当前的新版本mysql都已经实现了自动注册驱动，这句话实际上以后都可以不写了
        Connection connection = DriverManager.getConnection(url,properties);

        System.out.println(connection);
        connection.close();
    }
}
```



#### 11.4 PreparedStatement

> statement

在上面的示例中，会发现statement是非常重要的一个对象，因为要靠它来实现sql代码的执行。但是在真正用jdbc时，statement却是被淘汰掉的，而用PreparedStatement或者CallableStatement来操作sql语句。

这是因为statement对象执行sql语句时会存在sql注入的风险。

所谓sql注入，是指利用某些系统没有对用户的输入数据进行充分检查，而在用户输入中注入非法的sql语句，进而恶意攻击数据库。而PreparedStatement可以处理这种风险。

```mysql
select * from db where `name` = 'tom' and `pwd` = '123'; //常理来说应该这样来查询某个用户的信息，但是sql注入则用如下方法来注释掉这些语法

//将tom改为 -- 1' or 把123改为 -- or '1' = '1
select * from db where `name` = '1' or' and pwd = 'or '1' = '1' //这样一来把条件分为三部分，第一部分为`name` = '1' 第二部分则变为了' and pwd = ' 第三部分是'1' = '1'，这样第三部分是永远成立的，则可以直接查出该表的所有内容
```



而在java中用statement来进行sql语句的执行，也会出现sql注入的情况

```java
String name = "jack";
String pwd = "123";//先定义正确的name和密码。这里的账号密码需要用scanner.nextline方法来从键盘监听得到才行

String sql = "slect name , pwd from db where name = '" + name + "' and '" + pwd +"'";//定义要使用的查询语法，本来正确的查询应该是这样的
ResultSet resultSet = statement.executeQuery(sql);//使用statement来进行语法使用

String sqlbad = "select name ,pwd from db where name = ' 1' or' and ' or '1' = '1' ";则可zhi


```



> preparedStatement





#### 11.5JDBC的API

> DriverManager驱动管理类

该类是JDBC需要关注的第一个类，因为要通过它来管理mysql与java相连的驱动。

内部方法：

```java
new Driver().connection(url,properties); //提供connect方法，接受一个url（数据库的url，由数据库地址、端口和具体哪个数据库组成）,接受一个properties对象（配置流的对象，保存了开启数据库所需的账号密码，其格式也固定，账号为user、密码为password）
```





> connection接口

该接口对象是通过驱动生成的链接，相当于给数据库和java程序搭上了桥。其提供方法来决定桥上运输什么东西

内部方法

```java
new Connection().createStatement();//创建一个statement对象
new Connection().PreparedStatement(sql);//创建一个preparedStatement对象，创建时需要传入一个sql语句作为preparedStatement对象的构造参数
```





> statement接口

该接口的对象实际上就是用来从java程序中向mysql数据库下达具体命令用的，就是桥上从java向mysql运输的东西。其实现具体的sql语句

内部方法

```java
new Statement().executeUpdate(sql);//接受一个String类型的sql语句来让mysql执行，该方法用来执行增删改语句，返回一个int类型，表示此条增删改影响了几行记录

new Statement().executeQuery(sql);//接受一个String类型的sql语句来让mysql执行，该方法用来执行查询语句，返回一个ResultSet对象。

new Statement().execute(sql);//执行任意sql语句（除了上述的增删改查外，还有数据库创立、表的创立等等语句需要执行，就用这个方法），返回一个布尔值，表示成功还是失败
```





> PreparedStatement接口

该接口是statement接口的加强版，避免了sql注入问题，让数据库变得不那么容易被破解

其内部方法如下

```java
new PrepaerdStatement().executeUpdate();//该方法用来执行增删改语句，返回一个int类型，表示此条增删改影响了几行记录

new PreparedStatement().executeQuery();//该方法用来执行查询语句，返回一个ResultSet对象。

new PreparedStatement().execute();//返回一个布尔值，表示成功还是失败
//上三条和statement接口一样，不同的就是sql语句的接受在创建PreparedStatement对象时就通过构造器接受了，此处用方法直接执行

new PreparedStatement().setXXX(index,value);//向index位置的占位符上赋值value。XXX表示该占位符的数据类型
```



> ResultSet接口

该接口是进行表查询时（executeQuery方法）返回的对象，其本质是个结果集的指针。因为查询表过后会得到一个查询结果，这个结果也往往是一个比原表较小的表。此时resultset对象就指向该结果表的第零行（相当于刚开始指向空，要向下移动一行才是第一行）。



其内部方法如下

```java
resultset.next();//指针移动语句，一般放在while循环里使用。该方法的意思是，若结果表的下一行有值，则将指针下移，若没值，则返回false
resultset.previous();//指针向上移动的方法,若没有上一行了，则返回false
resultset.getInt(int/String);//该方法表示取指针所指行的某一列的数据，若传入的是int型，则是得到该行第int列的数据、若传入的是String型，则该String得是结果表中的某个列名，然后得到该行该列的数据
```



#### 11.6  JDBC Utils

通过上面的学习，会发现如果向执行多条sql语句，其有很多代码都是重复的，但是又不得不写（如链接数据库、关闭流等等），那么是不是可以做一个jdbc的工具类，将这些重复性高的代码封装起来，用的时候直接调用就行？

下面给出了JDBC的工具类

```java
public class _01_SCUtils {
    //首先定义四个固定的属性（数据库的用户名、密码，数据库的url和数据库的驱动）。为了方便使用并节省空间，将其定义为静态的
    private static String user;
    private static String password;
    private static String url;
    private static String driver; //这里driver好像没用到？

    //将上面四个属性在一个静态代码块中初始化
    static {
        Properties properties = new Properties();
        user = "root";
        password = "123456hlh789";
        url = "jdbc:mysql://localhost:3306/jdbc_study";
        driver = "com.mysql.jdbc.Driver";
    }

    //链接数据库，返回connection对象
    public static Connection getConnection() throws SQLException {

        return DriverManager.getConnection(url,user,password);
    }

    //关闭资源
    //可能被关闭的资源有：结果集指针（Resultset）、statement或PreparedStatemnt执行语句、Connection链接
    public static void close(ResultSet set, Statement statement, Connection connection) throws SQLException {

        //若需要关闭资源，则传入对象，否则传入null
        if(set != null) set.close();

        if(statement != null) statement.close();

        if(connection != null) connection.close();
    }
}
```



其实际应用如下

```java
public static void main(String[] args) throws SQLException {

        //得到连接
        Connection connection = _01_SCUtils.getConnection();

        //开始执行sql语言
        String sql = "insert into chapter2 values(?,?)";

        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        preparedStatement.setString(1,"01");
        preparedStatement.setString(2,"111");

        int i = preparedStatement.executeUpdate();
        System.out.println(i > 0 ? "执行成功" :"执行失败");

        //关闭资源
        _01_SCUtils.close(null,preparedStatement,connection);//由于没有Resultset，故传入null即可
    }
```



#### 11.7 事务操作

JDBC在创建一个connection对象时，默认是自动提交事务的，每执行一次sql语句自动提交一次，无法进行回滚；而想让jdbc一次执行多个sql语句并且保证这些语句一定要同时成功执行或同时不执行，就要应用上事务这个操作。

执行：connection.setAutoCommit(false)；这条语句，则可以取消自动提交事务，然后将想执行的多个sql语句进行各自的执行，等都执行完了之后在用connection.commit()；语句来进行同一提交，即可完成事务的操作。

当有操作出现意外需要回滚时，使用connnection.rollback()；操作进行回滚。



下面还以转账为例子：A向B转账，分两步，A扣100，B加100。这两部一定要保证同时成功或者失败，若只成功一部分，则要么A白亏100，要么B白赚100，会出大事。

```java
public class _02_withTranscation {
    public static void main(String[] args) {
        Driver driver = null;
        String url = "jdbc:mysql://localhost:3306/jdbc_study";
        Properties properties = new Properties();
        properties.setProperty("user","root");
        properties.setProperty("password","123456hlh789");
        Connection connection = null;
        try {
            driver = new Driver();
            connection = driver.connect(url,properties);
        } catch (SQLException e) {
            e.printStackTrace();
        }

        PreparedStatement preparedStatement = null;


        //使用事务进行操作
        //将提交设置成非自动提交

        String sql1 = "update chapter3 set balance = balance - 100 where name = 'JACK'";
        String sql2 = "update chapter3 set balance = balance + 100 where name = 'TOM'";


        try{

            connection.setAutoCommit(false);
            //先执行第一个第一个人扣钱部分
            preparedStatement = connection.prepareStatement(sql1);
            preparedStatement.executeUpdate();


            int i = 1 / 0;//故意添加一个错误
            //再执行第二个人加钱部分
            preparedStatement = connection.prepareStatement(sql2);
            preparedStatement.executeUpdate();

            //若是第二个人加钱和第一个人扣钱之间出现了差错，则会导致非常严重的问题。这里用0当除数来当作异常

            connection.commit();//若前面都没有异常则可在try最后顺利提交，若有异常，则会被cahtc住，而catch部分有回滚操作让刚刚的失误撤回。


        }catch (Exception e){
            System.out.println("出异常了");
            try {
                connection.rollback(); //当加入事务机制后，可以再catch部分加入回滚操作，当try部分有内容出现差错后，通过回滚滚到事务开始的地方（将自动提交设置成false的地方）或是自己设置的回滚点
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
            e.printStackTrace();
        }finally {
            try {
                preparedStatement.close();
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }


    }
}
```



#### 11.8 批处理

当需要同时处理多条sql语句时，可以使用java提供的批量处理机制，这一机制允许多条语句一次性提交给数据库进行批量处理，这样比单独处理一条条的语句更有效率。

其常用方法如下

```java
addBatch()//添加需要批量处理的sql语句或参数
executeBatch()//执行批处理语句
clearBatch()//清空批处理包的语句
```



要注意，想对数据库使用批处理，需要在连接数据库url时，加入参数：rewriteBatchedStatements=true，该语句与前方语句用问号隔开。

```java
public class _02_withBatch {
    public static void main(String[] args) throws SQLException {
        Driver driver = new Driver();
        String url = "jdbc:mysql://localhost:3306/jdbc_study?rewriteBatchedStatements=true";//这里注意把参数加上
        Properties properties = new Properties();
        properties.setProperty("user","root");
        properties.setProperty("password","123456hlh789");
        Connection connection = driver.connect(url,properties);


        PreparedStatement preparedStatement = null;
        String sql = "insert into chapter4 values(?,?)";

        preparedStatement = connection.prepareStatement(sql);

        long str = System.currentTimeMillis();
        //向表内添加10条记录
        for (int i = 0; i < 100 ; i++) {
            preparedStatement.setInt(1,i);
            preparedStatement.setInt(2,100);

            /**
             *其他地方和刚刚一样，就是这里要变了
             */
            preparedStatement.addBatch();
        }
        preparedStatement.executeBatch();//当批量添加结束后，进行一次批量执行
        long end = System.currentTimeMillis();
        System.out.println("耗时= " + (end - str)); //最后耗时5毫秒，时间上质变。
        preparedStatement.close();
        connection.close();
    }
}
```





### 12 连接池

#### 12.1 基本介绍

> 传统连接

传统的连接方式，在连接数据库的时候若用户接入过多，会导致数据库崩溃，

比如

```java
public class _question {
    public static void main(String[] args) throws SQLException {
        Driver driver = new Driver();

        String url = "jdbc:mysql://localhost:3306/jdbc_study";

        Properties properties = new Properties();
        properties.setProperty("user","root");
        properties.setProperty("password","123456hlh789");

        for (int i = 0; i < 1000; i++) {
            Connection connection = driver.connect(url,properties); //进行1000次数据库的连接
            //connection.close();//灵活关闭
        }
    }

    //若进行每次连接后不关闭连接，则最后报错：Too many connections ;若进行每次连接后关闭当此连接再进行下一次连接，则耗时非常长
}

```



传统连接的问题如下

1、传统的jdbc连接数据库，每次在连接时都要将connection加载到内存中，再验证ip地址、用户名和密码，这个过程即耗费空间，也耗费时间。多次频繁的进行该操作就很容易造成崩溃情况。

2、每一次传统的数据库的连接，使用完之后都得断开，若程序出错而未能正常关闭连接，会导致数据库的内存泄露，最终导致数据库崩溃。（内存泄露是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果）。

3、传统的连接，不能控制连接的数量，是个人拿着账号密码就能连，若连接的人过多最终容易导致内存泄漏。



> 数据库连接池

数据库连接池预先再缓冲池中放入一定数量的连接（以对象形式存在的连接），当需要建立连接时，只需要从缓存池中取出一个进行连接，连接完了再放回去。

数据库连接池负责分配、管理和释放数据库连接，它允许程序重复使用一个现有的数据库连接，而不是重新建立一个。

当程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。



#### 12.2 连接池种类

jdbc的连接池是使用javax.sql.DataSource来表示，DataSource是一个jdbc提供的接口，其具体实现是看各个第三方的实现。

其常见的连接池有如下几种：C3P0、DBCP、Proxool、BoneCP、Druid。其中最重要的是C3P0和Druid两种。最常用的是Druid连接池。



##### 12.2.1 C3P0

使用c3p0要首先去网上把它的对应的jar包加载到库中，和jdbc的connect那个jar包导入一个流程。



##### 12.2.2 Druid

德鲁伊连接池也要先将jar包导入。



#### 12.3 ApDBUtils

在java程序种操作数据库时，尤其是操作查询语句时，我们会在java中得到一个resultSet对象类型的结果集。但是有一个问题是该结果集是和connection对象高度同步的，如果连接关闭，该结果集也随之关闭了。

但是有很多时候，我们常常需要进行多表查询，即将一个表的查找结果当作要进行第二次操作的表。这时如果该结果集与connection相关度太高就会很麻烦。因为我们有时需要连接关闭后该结果集仍然能用。

也就是说，目前的需求是，想要让结果集是可以多次使用的，并且与connection不再相关。此时就需要使用ApDBUtils。



我们可以在java中做一个类，将一个表中的列名做成该类中的属性。比如现在有一个员工表，该表的列名分别为：id、name、sex。则可以在java中对应建立一个员工类，该类中有属性id、name、sex。这种与表有映射的类通常称为javaBean类或PoJO类。此时每个员工对象就相当于一个员工表中的记录

之后再将查询后的结果集封装到一个ArrayList集合中，该集合的泛型要指定为员工类。

这样就相当于将对数据库的查询结果保存在了java程序中的集合中，此时连接再与mysql断掉之后，也不会影响java内集合的信息。



ApDBUtils的核心思路就是这样操作。实际上刚刚的操作自己也是可以写出来的，就是写出来之后不太美观，也稍微费点劲。

ApDBUtils就提供了一个jdbc的工具类，极大的简化了jdbc的编码过程，其常用方法就在实例里面学习使用。（使用时记得把apdbutils的jar包导入）

该包下有以下几个重要的操作：

QueryRunner类：该类封装了sql语句的执行，是线程安全的，可以实现增删改查与批量处理

ResultSetHandler接口：该接口用于处理java.sql.ResultSet，将结果集转为另一种形式

ArrayHandler方法：把结果集中的第一行数据转换成对象数组

ArrayListHandler方法：把结果集中的第一行数据转换成对象数组再存放到list中

BeanHandler方法：将结果集中的第一行数据变为一个JavaBean类的对象

BeanListHandler方法：将结果集中的第一行数据变为一个JavaBean类的对象再存放到list中

ColumnListHandler方法：将结果集中某一列记录存放到list中





#### 12.4 BasicDAO

BasicDAO是为了改进ApDBUtils的不足的。



之前学的都是在一个表上进行操作，若现在有多个表需要进行操作，且每个表都要进行一系列操作，那么这些操作中，有增删改查等部分是重复的代码，就可以把这部分提取出来，集成一个类就叫做BasicDAO。

BasicDAO是基础数据访问对象的简称，所谓数据访问对象，实际上就是用来访问数据的对象。即用来完成对数据库增删改查的操作。在basicDAO的基础上，我们就可以做到每一张表对应一个DAO，以更好的处理表的信息。



DAO已经是一个很大的集成的概念了，它是用来操作多个表用的，多个表就意味着对应多个JavaBean类，也意味着要有多个专有的DAO对这些表进行一一对应的操作。







